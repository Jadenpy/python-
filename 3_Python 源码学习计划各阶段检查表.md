# Python 源码学习计划各阶段检查表

为了帮你精准跟踪每阶段学习进度，我将 8 周计划拆解为 **“周目标检查表”** 和 **“核心任务核查清单”** 两部分，每个任务都明确 “完成标准”（可量化、可验证），避免 “学了但没完全掌握” 的情况。你可每周结束后对照填写，也可每天花 5 分钟勾选当日完成项。

# Python 源码学习计划 —— 阶段检查表

（说明：“完成度” 按 0%/50%/100% 填写，“验证方式” 需实际操作确认，“问题记录” 用于后续复盘）

## 前置准备阶段检查表（开始前 1-2 天）



| 准备项          | 完成标准                                                                                                                                                                                                   | 完成度 | 验证方式                                                                                                 | 问题记录 |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --- | ---------------------------------------------------------------------------------------------------- | ---- |
| 1. 源码阅读环境搭建  | 1. Python 3.9+ 已安装（终端输入 `python --version` 能显示版本）；2. PyCharm/VS Code 已配置 “跳转定义” 功能（按住 Ctrl 点击函数名能跳源码）；3. Git 已安装（终端输入 `git --version` 能显示版本）。                                                          |     | 1. 执行 `python --version` 确认；2. 用 IDE 打开 `datetime.py`，点击 `date.today()` 跳转；3. 执行 `git --version` 确认。 |      |
| 2. 源码获取      | 1. 内置库：找到 Python 安装目录的 `Lib` 文件夹（含 `datetime.py` `json.py`）；2. 三方库：`requests` `pydantic` 源码已克隆（本地有 `requests/` `pydantic/` 文件夹）；3. 项目：`FastAPI` `Django` 源码已克隆（本地有 `fastapi/` `django/db/models/` 目录）。 |     | 1. 打开文件夹确认文件存在；2. 终端执行 `ls requests/`（Linux/macOS）或 `dir requests/`（Windows）确认。                      |      |
| 3. 辅助工具 / 文档 | 1. `pydoc` 可用（终端执行 `pydoc datetime` 能显示文档）；2. 4 个库 / 项目的官方文档已收藏；3. Markdown 笔记文档已创建（命名如 “Python 源码学习笔记.md”）。                                                                                           |     | 1. 执行 `pydoc datetime` 查看输出；2. 打开浏览器书签确认文档链接；3. 打开笔记文档确认结构（含 “风格总结”“思路提炼” 章节）。                       |      |
| 4. 基础认知回顾    | 1. 能写出 “继承 + 组合” 的简单 OOP 代码（如 “学生类包含成绩类”）；2. 能用 `requests` 发 GET 请求、用 `pydantic.BaseModel` 定义数据模型并验证。                                                                                                  |     | 1. 运行自己写的 OOP 代码，确认功能正常；2. 运行 `requests.get("https://www.baidu.com")` 和 `pydantic` 验证代码，确认无报错。       |      |

## 第 1 周：内置库 `datetime` 学习检查表



| 核心任务                | 完成标准                                                                                                                                 | 完成度 | 验证方式                                                                                                                                             | 问题记录 |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | --- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ---- |
| 1. 学习 `date` 类      | 1. 看懂 `date.__init__` 方法（理解 `year/month/day` 的参数校验逻辑）；2. 看懂 `date.today()` 方法（知道如何获取当前日期）；3. 看懂 `date.strftime()` 方法（知道格式符号如何映射到日期）。 |     | 1. 在 IDE 中找到 `date.__init__`，标注参数校验代码（如 `_check_date` 调用）；2. 运行 `date.today()`，对比源码解释输出结果；3. 写代码 `date(2024,9,1).strftime("%Y-%m-%d")`，结合源码说明结果。 |      |
| 2. 学习 `time` 类      | 1. 看懂 `time.__init__` 方法（理解 `hour/minute/second/microsecond` 的范围限制）；2. 知道 `time.utcoffset()` 方法的作用（时区偏移）。                            |     | 1. 尝试创建 `time(25, 0, 0)`，观察报错，结合源码 `_check_time` 解释原因；2. 在笔记中记录 `utcoffset()` 的返回值含义（如 `None` 表示无时区）。                                            |      |
| 3. 学习 `datetime` 类  | 1. 看懂 `datetime` 如何继承 `date` 并组合 `time` 功能；2. 看懂 `datetime.__add__` 方法（知道如何与 `timedelta` 交互）。                                        |     | 1. 在 IDE 中查看 `datetime` 的父类，标注 `time` 相关属性（如 `hour` `minute`）；2. 写代码 `datetime(2024,9,1) + timedelta(days=1)`，结合源码 `__add__` 解释结果。               |      |
| 4. 学习 `timedelta` 类 | 1. 看懂 `timedelta.__init__` 方法（理解 `days/seconds/microseconds` 的换算逻辑）；2. 看懂 `timedelta.total_seconds()` 方法（知道如何计算总秒数）。                 |     | 1. 写代码 `timedelta(hours=1, minutes=30)`，结合源码计算 `seconds` 属性值（3600+1800=5400）；2. 运行 `timedelta(days=1).total_seconds()`，结合源码解释结果（86400.0）。        |      |
| 5. 总结 `datetime` 设计 | 1. 笔记中列出 `datetime` 的 “类职责划分”（如 `date` 管日期，`time` 管时间）；2. 记录 1-2 个 “边界处理” 案例（如闰年 2 月、跨月日期）。                                          |     | 1. 检查笔记中是否有清晰的类职责表格；2. 举例说明 `date(2024,2,29)` 为何合法，`date(2023,2,29)` 为何报错，结合源码 `_check_date` 解释。                                                 |      |

## 第 2 周：内置库 `json` 学习检查表



| 核心任务                  | 完成标准                                                                                                       | 完成度 | 验证方式                                                                                                                                                                             | 问题记录 |
| --------------------- | ---------------------------------------------------------------------------------------------------------- | --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| 1. 学习 `dumps()` 函数    | 1. 看懂 `dumps()` 调用链路（`dumps` → `JSONEncoder.encode`）；2. 知道 `ensure_ascii=False` `indent=2` 的参数作用（源码中如何处理）。 |     | 1. 在 IDE 中跟踪 `dumps` 函数，标注 `cls=JSONEncoder` 的调用；2. 写代码 `json.dumps({"name":"张三"}, ensure_ascii=False, indent=2)`，结合源码解释中文显示和缩进效果。                                               |      |
| 2. 学习 `JSONEncoder` 类 | 1. 看懂 `JSONEncoder.encode()` 方法（核心序列化逻辑）；2. 看懂 `JSONEncoder.default()` 方法（如何处理非标准类型）。                      |     | 1. 在源码中找到 `encode()` 方法，标注 `_iterencode` 的调用（迭代序列化）；2. 重写 `default` 方法实现 `datetime` 序列化（如 `return obj.isoformat()`），运行代码验证。                                                      |      |
| 3. 学习 `loads()` 函数    | 1. 看懂 `loads()` 调用链路（`loads` → `JSONDecoder.decode`）；2. 知道 `object_hook` 参数的作用（源码中如何应用）。                   |     | 1. 跟踪 `loads` 函数，标注 `cls=JSONDecoder` 的调用；2. 写代码 `json.loads('{"date":"2024-09-01"}', object_hook=lambda d: datetime.strptime(d["date"], "%Y-%m-%d"))`，结合源码解释 `object_hook` 的作用。 |      |
| 4. 学习 `JSONDecoder` 类 | 1. 看懂 `JSONDecoder.decode()` 方法（核心反序列化逻辑）；2. 知道 `parse_object` 方法如何解析 JSON 对象。                             |     | 1. 在源码中找到 `decode()` 方法，标注 `self.parse_object` 的调用；2. 笔记中记录 `parse_object` 如何将 JSON 键值对转为 Python 字典。                                                                             |      |
| 5. 总结 `json` 分层逻辑     | 1. 笔记中画出 `json` 库的 “三层结构”（底层细节→中层扩展→顶层 API）；2. 记录 “通用规则 + 自定义扩展” 的设计思路（如序列化如何兼容标准与非标准类型）。                  |     | 1. 检查笔记中的分层结构图是否清晰（标注每层的核心类 / 函数）；2. 举例说明 `json` 如何处理 `dict`（通用）和 `datetime`（自定义），结合思路总结。                                                                                        |      |

## 第 3 周：三方库 `requests` 学习检查表



| 核心任务                                   | 完成标准                                                                                                                                  | 完成度 | 验证方式                                                                                                                                                                                       | 问题记录 |
| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---- |
| 1. 学习顶层 API（`api.py`）                  | 1. 看懂 `get()` `post()` 函数的实现（知道如何创建临时 `Session`）；2. 知道 `requests.get()` 与 `Session.get()` 的关系。                                        |     | 1. 在 `api.py` 中找到 `get` 函数，标注 `session = Session()` 的代码；2. 写代码对比 `requests.get(url)` 和 `Session().get(url)` 的效果，结合源码解释差异（如 Cookie 是否持久）。                                                   |      |
| 2. 学习 `Session` 类（`sessions.py`）       | 1. 看懂 `Session.__init__` 方法（知道如何初始化 `adapters` `cookies`）；2. 看懂 `Session.request()` 方法（核心请求逻辑，如准备请求、发送请求、处理响应）。                       |     | 1. 在源码中找到 `Session.__init__`，标注 `self.adapters = OrderedDict()` 的初始化；2. 跟踪 `Session.request()` 链路，标注 `self.prepare_request(req)` 和 `self.send(prep)` 的调用。                                  |      |
| 3. 学习 `PreparedRequest` 类（`models.py`） | 1. 看懂 `PreparedRequest.prepare()` 方法（知道如何组装 `url` `headers` `body`）；2. 知道 `prepare_url()` 方法如何处理 `params` 参数（拼接查询字符串）。                |     | 1. 写代码 `req = PreparedRequest(); req.prepare(url="https://www.baidu.com", params={"wd":"python"})`，打印 `req.url` 确认参数拼接，结合源码 `prepare_url` 解释；2. 笔记中记录 `prepare()` 方法的步骤（url→headers→body）。 |      |
| 4. 学习 `HTTPAdapter` 类（`adapters.py`）   | 1. 知道 `HTTPAdapter` 如何管理连接池（依赖 `urllib3.PoolManager`）；2. 看懂 `HTTPAdapter.send()` 方法（如何发送请求并返回响应）。                                     |     | 1. 在源码中找到 `HTTPAdapter.__init__`，标注 `self.poolmanager = PoolManager(...)` 的代码；2. 笔记中记录 `HTTPAdapter` 的作用（隔离连接细节，让 `Session` 专注于逻辑）。                                                        |      |
| 5. 总结组件协作逻辑                            | 1. 笔记中画出 `requests` 的组件链路（`get()`→`Session`→`PreparedRequest`→`HTTPAdapter`→`Response`）；2. 记录 “隐藏复杂度” 的设计风格（如用户无需关心连接池，只需调用 `get()`）。 |     | 1. 检查链路图是否完整，标注每个组件的核心作用；2. 举例说明 `requests` 如何隐藏 “连接复用” 的细节（用户无需配置，`HTTPAdapter` 自动处理）。                                                                                                    |      |

## 第 4 周：三方库 `pydantic` 学习检查表



| 核心任务                                                         | 完成标准                                                                                             | 完成度 | 验证方式                                                                                                                                                                                  | 问题记录 |
| ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------ | --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| 1. 学习 `BaseModel` 类（`main.py`）                               | 1. 看懂 `BaseModel.__init__` 方法（知道如何初始化字段并触发验证）；2. 知道 `__fields__` 属性的作用（存储字段元数据）。                 |     | 1. 写代码 `class User(BaseModel): name: str; age: int; u = User(name="Alice", age=25)`，在 IDE 中查看 `u.__fields__` 的内容，结合源码 `__init__` 解释；2. 笔记中记录 `__init__` 如何调用 `_validate_fields` 触发验证。 |      |
| 2. 学习 `Field` 类（`fields.py`）                                 | 1. 看懂 `Field` 如何定义字段规则（如 `ge` `max_length`）；2. 知道 `Field` 与 `BaseModel` 的关联（如何将规则传入模型）。          |     | 1. 写代码 `class User(BaseModel): age: int = Field(ge=0)`，尝试创建 `User(age=-1)` 观察报错，结合 `Field` 源码解释 `ge` 的作用；2. 在源码中找到 `BaseModel` 如何收集 `Field` 定义（通过元类）。                                 |      |
| 3. 学习内置验证器（`validators.py`）                                  | 1. 看懂一个内置验证器（如 `int_validator`）的逻辑（如何校验整数类型）；2. 知道验证器如何与 `Field` 规则结合（如 `ge` 如何触发范围校验）。          |     | 1. 在源码中找到 `int_validator`，标注 `if v < gt` 等范围校验代码；2. 笔记中记录 `int_validator` 的调用链路（`BaseModel`→`_validate_fields`→`int_validator`）。                                                      |      |
| 4. 学习元类 `ModelMetaclass`（`_internal/_model_construction.py`） | 1. 看懂元类如何解析 `BaseModel` 子类的字段（如 `name: str`）；2. 知道 `__new__` 方法如何生成 `__fields__` 属性。             |     | 1. 在源码中找到 `ModelMetaclass.__new__`，标注 `fields = collect_model_fields(cls, bases, attrs)` 的代码；2. 笔记中记录元类的作用（在类定义时自动处理字段，无需用户手动注册）。                                                     |      |
| 5. 总结元编程设计                                                   | 1. 笔记中记录 `pydantic` 元编程的使用场景（如解析字段、生成验证逻辑）；2. 对比 “不用元编程” 的实现方式（如手动调用 `register_field`），说明元编程的优势。 |     | 1. 检查笔记中是否有元编程场景的具体案例；2. 尝试用 “无元编程” 的方式写一个简单数据模型（如手动定义 `__fields__`），对比 `pydantic` 的实现，记录元编程的简化效果。                                                                                    |      |

## 第 5-6 周：项目 `FastAPI` 学习检查表（分 2 周）

### 第 5 周：`APIRoute` 与 `APIRouter`



| 核心任务                              | 完成标准                                                                                                                         | 完成度 | 验证方式                                                                                                          | 问题记录 |
| --------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | --- | ------------------------------------------------------------------------------------------------------------- | ---- |
| 1. 学习 `APIRoute` 类（`routing.py`）  | 1. 看懂 `APIRoute.__init__` 方法（知道如何封装 `endpoint` `methods` `response_class`）；2. 知道 `APIRoute.handle_request` 方法的作用（处理请求并返回响应）。 |     | 1. 在源码中找到 `APIRoute.__init__`，标注 `self.endpoint = endpoint` 的代码；2. 笔记中记录 `APIRoute` 的核心职责（封装一个接口的 “逻辑 + 配置”）。 |      |
| 2. 学习 `APIRouter` 类（`routing.py`） | 1. 看懂 `APIRouter.add_api_route` 方法（知道如何添加 `APIRoute` 到路由表）；2. 看懂 \`APIRouter.include\_                                       |     |                                                                                                               |      |

> （注：文档部分内容可能由 AI 生成）